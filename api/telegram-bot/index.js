require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');

const requiredEnvVars = {
  TELEGRAM_BOT_TOKEN: process.env.TELEGRAM_BOT_TOKEN,
  FLOWISE_URL: process.env.FLOWISE_URL,
  CHATFLOW_ID: process.env.CHATFLOW_ID,
};

Object.entries(requiredEnvVars).forEach(([key, value]) => {
  if (!value) {
    console.error(`Error: ${key} not found in environment variables`);
    process.exit(1);
  }
});

const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const FLOWISE_URL = process.env.FLOWISE_URL;
const CHATFLOW_ID = process.env.CHATFLOW_ID;
const FLOWISE_API_KEY = process.env.FLOWISE_API_KEY;

const userLastMessage = new Map();
const conversationHistory = new Map();
const RATE_LIMIT_MS = 3000;
const MAX_MESSAGE_LENGTH = 2000;
const MAX_HISTORY_TURNS = 20;

function sanitizeText(text) {
  if (!text) return text;
  return Buffer.from(text, 'utf8').toString('utf8');
}

function logFlowiseRequest(chatId, question, history) {
  const turnCount = Math.floor(history.length / 2);
  console.log(
    `[Telegram] Flowise request chatId=${chatId} historyTurns=${turnCount} questionLength=${question.length}`
  );
}

function logFlowiseResponse(chatId, answer) {
  console.log(
    `[Telegram] Flowise response chatId=${chatId} replyLength=${answer.length}`
  );
}

function getHistory(chatId) {
  return conversationHistory.get(chatId) || [];
}

function saveTurn(chatId, userMessage, botReply) {
  const existing = conversationHistory.get(chatId) || [];
  const updated = existing.concat([
    ['user', userMessage],
    ['assistant', botReply],
  ]);
  const maxEntries = MAX_HISTORY_TURNS * 2;
  const trimmed =
    updated.length > maxEntries
      ? updated.slice(updated.length - maxEntries)
      : updated;
  conversationHistory.set(chatId, trimmed);
  console.log(
    `[Telegram] Stored history chatId=${chatId} messages=${trimmed.length}`
  );
}

function resetHistory(chatId) {
  conversationHistory.delete(chatId);
  console.log(`[Telegram] History reset chatId=${chatId}`);
}

const bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true });

console.log('‚úÖ Telegram bot started and ready');

bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const firstName = msg.from.first_name || '';

  resetHistory(chatId);

  bot.sendMessage(
    chatId,
    `–ü—Ä–∏–≤–µ—Ç, ${firstName}!\n\n–ï—Å–ª–∏ –Ω—É–∂–Ω–∞ –º–æ—è –ø–æ–º–æ—â—å —Å —Ä–µ–º–æ–Ω—Ç–æ–º –∏–ª–∏ –¥–∏–∑–∞–π–Ω–æ–º –∏–Ω—Ç–µ—Ä—å–µ—Ä–∞ ‚Äî –æ–±—Ä–∞—â–∞–π—Å—è. –ë—É–¥—É —Ä–∞–¥ –ø–æ–º–æ—á—å üòâ`
  );
});

bot.on('message', async (msg) => {
  if (msg.text && msg.text.startsWith('/')) {
    return;
  }

  const chatId = msg.chat.id;
  const userMessage = msg.text;

  if (!userMessage) {
    await bot.sendMessage(
      chatId,
      'üìù –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –Ø –ø–æ–∫–∞ –Ω–µ —É–º–µ—é –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã.'
    );
    return;
  }

  if (userMessage.length > MAX_MESSAGE_LENGTH) {
    await bot.sendMessage(
      chatId,
      `‚ö†Ô∏è –°–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (${userMessage.length} —Å–∏–º–≤–æ–ª–æ–≤). –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∫—Ä–∞—Ç–∏—Ç–µ –¥–æ ${MAX_MESSAGE_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤.`
    );
    return;
  }

  const now = Date.now();
  const lastMessageTime = userLastMessage.get(chatId) || 0;

  if (now - lastMessageTime < RATE_LIMIT_MS) {
    return;
  }

  userLastMessage.set(chatId, now);

  const typingInterval = setInterval(() => {
    bot.sendChatAction(chatId, 'typing').catch(() => {});
  }, 4000);

  await bot.sendChatAction(chatId, 'typing');

  try {
    const sanitizedMessage = sanitizeText(userMessage);
    const history = getHistory(chatId);
    logFlowiseRequest(chatId, sanitizedMessage, history);

    const response = await axios.post(
      `${FLOWISE_URL}/api/v1/prediction/${CHATFLOW_ID}`,
      {
        question: sanitizedMessage,
        history,
        overrideConfig: {
          sessionId: `telegram_${chatId}`,
        },
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          ...(FLOWISE_API_KEY && {
            Authorization: `Bearer ${FLOWISE_API_KEY}`,
          }),
        },
        responseEncoding: 'utf8',
      }
    );

    const botReply =
      response.data.text ||
      response.data.answer ||
      '–ò–∑–≤–∏–Ω–∏—Ç–µ, –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ –º–æ–≥—É –≤–∞–º –æ—Ç–≤–µ—Ç–∏—Ç—å.';

    saveTurn(chatId, sanitizedMessage, botReply);
    logFlowiseResponse(chatId, botReply);

    clearInterval(typingInterval);
    await bot.sendMessage(chatId, botReply);
  } catch (error) {
    clearInterval(typingInterval);

    console.error('‚ùå Flowise API error:', error.message);

    await bot.sendMessage(
      chatId,
      'üòî –ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ –Ω–∞–ø—Ä—è–º—É—é.'
    );
  }
});

bot.on('polling_error', (error) => {
  console.error('‚ùå Polling error:', error.message);
});

process.on('SIGTERM', () => {
  console.log('üõë Received SIGTERM, shutting down gracefully...');
  bot.stopPolling();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üõë Received SIGINT, shutting down gracefully...');
  bot.stopPolling();
  process.exit(0);
});
